# üì∏ T√çNH NƒÇNG CHAT G·ª¨I ·∫¢NH V√Ä VIDEO CALL - CHI TI·∫æT T·ª™NG FUNCTION

## üìñ M·ª§C L·ª§C

1. [T√≠nh nƒÉng Chat G·ª≠i ·∫¢nh](#1-t√≠nh-nƒÉng-chat-g·ª≠i-·∫£nh)
2. [T√≠nh nƒÉng Video Call](#2-t√≠nh-nƒÉng-video-call)
3. [Flow Diagrams](#3-flow-diagrams)
4. [Troubleshooting](#4-troubleshooting)

---

# 1. T√çNH NƒÇNG CHAT G·ª¨I ·∫¢NH

## üìä T·ªïng Quan

**Files li√™n quan:**
```
Frontend:
‚îú‚îÄ‚îÄ image-upload.component.ts        # UI component cho upload
‚îú‚îÄ‚îÄ upload.service.ts                # Service x·ª≠ l√Ω upload
‚îú‚îÄ‚îÄ message.service.ts               # Service g·ª≠i message
‚îî‚îÄ‚îÄ chat.component.ts                # Component chat ch√≠nh

Backend:
‚îú‚îÄ‚îÄ upload.middleware.ts             # Middleware x·ª≠ l√Ω file
‚îú‚îÄ‚îÄ upload.routes.ts                 # API routes
‚îî‚îÄ‚îÄ message.controller.ts            # Controller g·ª≠i message
```

**Tech Stack:**
- Frontend: Angular, RxJS
- Backend: Express, Multer, Sharp
- File Storage: Local filesystem (uploads/)

---

## üîß CHI TI·∫æT T·ª™NG FUNCTION

### FRONTEND - ImageUploadComponent

**File:** `Frontend_system/chat-system-frontend/src/app/components/shared/Common/image-upload.component.ts`

---

#### **Function 1: onFileSelected(event: Event)**

**M·ª•c ƒë√≠ch:** X·ª≠ l√Ω khi user ch·ªçn file

**Code:**
```typescript
onFileSelected(event: Event): void {
  const input = event.target as HTMLInputElement;
  const files = input.files;

  if (!files || files.length === 0) return;

  if (this.multiple) {
    this.handleMultipleFiles(Array.from(files));
  } else {
    this.handleSingleFile(files[0]);
  }
}
```

**Chi ti·∫øt t·ª´ng d√≤ng:**

| D√≤ng | Code | L√†m g√¨ | Gi·∫£i th√≠ch |
|------|------|--------|------------|
| 1 | `const input = event.target as HTMLInputElement` | Type casting | Convert event.target v·ªÅ HTMLInputElement ƒë·ªÉ access .files property |
| 2 | `const files = input.files` | L·∫•y files | FileList object ch·ª©a file(s) user ch·ªçn |
| 3 | `if (!files \|\| files.length === 0) return` | Validation | N·∫øu kh√¥ng c√≥ file ‚Üí exit function |
| 4 | `if (this.multiple)` | Check mode | Multiple files hay single file? |
| 5 | `this.handleMultipleFiles(Array.from(files))` | Multiple mode | Convert FileList ‚Üí Array r·ªìi x·ª≠ l√Ω nhi·ªÅu files |
| 6 | `this.handleSingleFile(files[0])` | Single mode | X·ª≠ l√Ω 1 file duy nh·∫•t |

**Flow Diagram:**
```
User clicks "Upload Image" button
  ‚Üì
File picker opens
  ‚Üì
User selects image(s)
  ‚Üì
onFileSelected() triggered
  ‚Üì
  ‚îú‚îÄ> multiple = true?  ‚Üí handleMultipleFiles()
  ‚îî‚îÄ> multiple = false? ‚Üí handleSingleFile()
```

---

#### **Function 2: handleSingleFile(file: File)**

**M·ª•c ƒë√≠ch:** X·ª≠ l√Ω 1 file ƒë∆∞·ª£c ch·ªçn

**Code:**
```typescript
private handleSingleFile(file: File): void {
  if (!this.validateFile(file)) return;

  this.previewUrl = URL.createObjectURL(file);
  this.imageSelected.emit(file);
}
```

**Chi ti·∫øt t·ª´ng d√≤ng:**

| D√≤ng | Code | L√†m g√¨ | Technical Detail |
|------|------|--------|------------------|
| 1 | `if (!this.validateFile(file))` | Validate file | Check type & size |
| 2 | `return` | Exit n·∫øu invalid | Stop processing |
| 3 | `URL.createObjectURL(file)` | T·∫°o preview URL | T·∫°o blob:// URL ƒë·ªÉ preview image |
| 4 | `this.previewUrl = ...` | Store URL | Assign to component property |
| 5 | `this.imageSelected.emit(file)` | Emit event | G·ª≠i File object cho parent component |

**createObjectURL() l√† g√¨?**
```javascript
Input: File object (binary data)
  ‚Üì
URL.createObjectURL(file)
  ‚Üì
Output: "blob:http://localhost:4200/abc-123-def-456"
  ‚Üì
Usage: <img [src]="previewUrl">
  ‚Üì
Browser hi·ªÉn th·ªã image t·ª´ memory (kh√¥ng c·∫ßn upload server!)
```

**Memory Management:**
```javascript
// Create URL
this.previewUrl = URL.createObjectURL(file);
// Memory allocated ‚úÖ

// MUST revoke when done!
URL.revokeObjectURL(this.previewUrl);
// Memory freed ‚úÖ

// If not revoked ‚Üí Memory leak! ‚ùå
```

---

#### **Function 3: validateFile(file: File)**

**M·ª•c ƒë√≠ch:** Validate file type v√† size

**Code:**
```typescript
private validateFile(file: File): boolean {
  // Check file type
  if (!this.allowedTypes.includes(file.type)) {
    this.snackBar.open(
      `File type ${file.type} is not allowed`, 
      'Close', 
      { duration: 3000 }
    );
    return false;
  }

  // Check file size
  if (file.size > this.maxSize) {
    this.snackBar.open(
      `File size must be less than ${this.maxSize / (1024 * 1024)}MB`, 
      'Close', 
      { duration: 3000 }
    );
    return false;
  }

  return true;
}
```

**Chi ti·∫øt validation:**

**Step 1: Check File Type**
```javascript
file.type = "image/jpeg"
allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp']

Check: allowedTypes.includes(file.type)
  ‚Üì
Result: true ‚úÖ ‚Üí Continue
```

**Step 2: Check File Size**
```javascript
file.size = 3145728 (bytes)  // 3MB
maxSize = 5242880 (bytes)    // 5MB default

Check: file.size > maxSize
  ‚Üì
3145728 > 5242880 = false
  ‚Üì
Result: Valid ‚úÖ ‚Üí Continue
```

**Error Cases:**
```javascript
// Case 1: Wrong type
file.type = "application/pdf"
  ‚Üì
allowedTypes.includes("application/pdf") = false
  ‚Üì
Show snackbar: "File type application/pdf is not allowed"
  ‚Üì
return false ‚ùå

// Case 2: Too large
file.size = 10485760 (10MB)
maxSize = 5242880 (5MB)
  ‚Üì
10485760 > 5242880 = true
  ‚Üì
Show snackbar: "File size must be less than 5MB"
  ‚Üì
return false ‚ùå
```

**Allowed Types:**
```
‚úÖ image/jpeg  ‚Üí .jpg, .jpeg
‚úÖ image/png   ‚Üí .png
‚úÖ image/gif   ‚Üí .gif
‚úÖ image/webp  ‚Üí .webp
‚ùå image/svg+xml (not allowed - security)
‚ùå image/bmp (not allowed - large size)
```

---

#### **Function 4: removeImage()**

**M·ª•c ƒë√≠ch:** X√≥a image preview v√† reset input

**Code:**
```typescript
removeImage(): void {
  if (this.previewUrl) {
    URL.revokeObjectURL(this.previewUrl);
    this.previewUrl = null;
  }

  if (this.fileInput) {
    this.fileInput.nativeElement.value = '';
  }
}
```

**Chi ti·∫øt t·ª´ng b∆∞·ªõc:**

| Step | Code | Purpose | Memory Impact |
|------|------|---------|---------------|
| 1 | `if (this.previewUrl)` | Check exists | Avoid null error |
| 2 | `URL.revokeObjectURL(this.previewUrl)` | Free memory | Release blob URL t·ª´ memory |
| 3 | `this.previewUrl = null` | Clear reference | Set property to null |
| 4 | `this.fileInput.nativeElement.value = ''` | Reset input | Clear file input value ƒë·ªÉ c√≥ th·ªÉ ch·ªçn l·∫°i same file |

**Memory Leak Prevention:**
```
Without revoke:
  createObjectURL() ‚Üí Blob URL created
  Image removed from UI
  Blob URL still in memory ‚ùå
  Multiple uploads ‚Üí Memory increases
  Eventually ‚Üí Browser crash! ‚ùå

With revoke:
  createObjectURL() ‚Üí Blob URL created
  Image removed from UI
  revokeObjectURL() ‚Üí Memory freed ‚úÖ
  Clean! No memory leaks! ‚úÖ
```

**Reset Input Value:**
```html
<input type="file" value="">
```

**Why reset?**
```
User selects: photo1.jpg
  ‚Üì
Remove image
  ‚Üì
User tries to select photo1.jpg AGAIN
  ‚Üì
Without reset: onChange NOT triggered (same file)
With reset: onChange triggered ‚úÖ
```

---

### FRONTEND - UploadService

**File:** `Frontend_system/chat-system-frontend/src/app/services/upload.service.ts`

---

#### **Function 5: uploadImage(file: File, channelId?: string)**

**M·ª•c ƒë√≠ch:** Upload image to server

**Code:**
```typescript
uploadImage(file: File, channelId?: string): Observable<ImageUploadResponse> {
  const formData = new FormData();
  formData.append('image', file);
  if (channelId) {
    formData.append('channelId', channelId);
  }

  return this.http.post<ImageUploadResponse>(
    `${this.API_URL}/image`, 
    formData, 
    {
      headers: {
        'Authorization': this.authService.getToken() 
          ? `Bearer ${this.authService.getToken()}` 
          : ''
      }
    }
  );
}
```

**Chi ti·∫øt t·ª´ng d√≤ng:**

| D√≤ng | Code | L√†m g√¨ | Technical Detail |
|------|------|--------|------------------|
| 1 | `const formData = new FormData()` | Create FormData | Container cho multipart/form-data |
| 2 | `formData.append('image', file)` | Append file | Add File object with key 'image' |
| 3 | `if (channelId)` | Optional param | Check if channelId provided |
| 4 | `formData.append('channelId', channelId)` | Add metadata | Backend c√≥ th·ªÉ link image v·ªõi channel |
| 5-9 | `this.http.post(...)` | HTTP POST | Send FormData to backend |
| 10-12 | `headers: { Authorization: ... }` | Auth header | JWT token cho authentication |

**FormData Explained:**
```javascript
// FormData creates multipart/form-data request

const formData = new FormData();
formData.append('image', file);
formData.append('channelId', 'channel-123');

// HTTP Request:
POST /api/upload/image
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="image"; filename="photo.jpg"
Content-Type: image/jpeg

[BINARY DATA OF IMAGE]
------WebKitFormBoundary
Content-Disposition: form-data; name="channelId"

channel-123
------WebKitFormBoundary--
```

**Observable Pattern:**
```typescript
// Call uploadImage()
this.uploadService.uploadImage(file, channelId)
  .subscribe({
    next: (response) => {
      // Success!
      console.log('Image uploaded:', response.data.imageUrl);
    },
    error: (error) => {
      // Failed!
      console.error('Upload failed:', error);
    }
  });
```

---

#### **Function 6: uploadImageWithProgress(file: File, channelId?: string)**

**M·ª•c ƒë√≠ch:** Upload v·ªõi progress tracking

**Code:**
```typescript
uploadImageWithProgress(
  file: File, 
  channelId?: string
): Observable<{ progress?: UploadProgress; response?: ImageUploadResponse }> {
  
  const formData = new FormData();
  formData.append('image', file);
  if (channelId) {
    formData.append('channelId', channelId);
  }

  return this.http.post<ImageUploadResponse>(
    `${this.API_URL}/image`, 
    formData, 
    {
      headers: {
        'Authorization': this.authService.getToken() 
          ? `Bearer ${this.authService.getToken()}` 
          : ''
      },
      reportProgress: true,
      observe: 'events'
    }
  ).pipe(
    map((event: HttpEvent<ImageUploadResponse>) => {
      if (event.type === HttpEventType.UploadProgress) {
        const progress = event.total 
          ? Math.round((100 * event.loaded) / event.total) 
          : 0;
        return { progress: { loaded: event.loaded, total: event.total || 0, percentage: progress } };
      } else if (event.type === HttpEventType.Response) {
        return { response: event.body || undefined };
      }
      return {};
    })
  );
}
```

**Chi ti·∫øt HTTP Events:**

**HttpEventType explained:**
```typescript
enum HttpEventType {
  Sent = 0,              // Request ƒë∆∞·ª£c g·ª≠i
  UploadProgress = 1,    // Upload ƒëang progress
  ResponseHeader = 2,    // Nh·∫≠n ƒë∆∞·ª£c response headers
  DownloadProgress = 3,  // Download ƒëang progress
  Response = 4,          // Nh·∫≠n ƒë∆∞·ª£c full response
  User = 5              // Custom event
}
```

**Progress Tracking:**
```javascript
Upload 5MB image:

Event 1: UploadProgress
  loaded: 524288 (512KB)
  total: 5242880 (5MB)
  percentage: 10%
    ‚Üì emit progress

Event 2: UploadProgress
  loaded: 1048576 (1MB)
  total: 5242880 (5MB)
  percentage: 20%
    ‚Üì emit progress

... (continues)

Event 10: UploadProgress
  loaded: 5242880 (5MB)
  total: 5242880 (5MB)
  percentage: 100%
    ‚Üì emit progress

Event 11: Response
  body: { success: true, data: { imageUrl: "..." } }
    ‚Üì emit response
```

**UI Update:**
```typescript
this.uploadService.uploadImageWithProgress(file, channelId)
  .subscribe({
    next: (result) => {
      if (result.progress) {
        // Update progress bar
        this.uploadProgress = result.progress.percentage;
      }
      if (result.response) {
        // Upload complete!
        this.imageUrl = result.response.data.imageUrl;
      }
    }
  });
```

**Progress Bar UI:**
```
Uploading... 45%
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
```

---

#### **Function 7: validateFile(file: File)**

**ƒê√£ gi·∫£i th√≠ch chi ti·∫øt ·ªü tr√™n** (Function 3)

**B·ªï sung:**

**File Properties:**
```javascript
File object properties:
{
  name: "vacation-photo.jpg",
  size: 3145728,              // 3MB in bytes
  type: "image/jpeg",         // MIME type
  lastModified: 1696723200000, // Timestamp
  webkitRelativePath: ""      // For folder uploads
}
```

**Validation Logic:**
```javascript
Validate Type:
  ‚úÖ image/jpeg ‚Üí PASS
  ‚úÖ image/png  ‚Üí PASS
  ‚ùå video/mp4  ‚Üí FAIL

Validate Size:
  file.size = 3MB
  maxSize = 5MB
  ‚úÖ 3MB < 5MB ‚Üí PASS

  file.size = 8MB
  maxSize = 5MB
  ‚ùå 8MB > 5MB ‚Üí FAIL
```

---

### FRONTEND - MessageService

**File:** `Frontend_system/chat-system-frontend/src/app/services/message.service.ts`

---

#### **Function 8: sendImageMessage(channelId, imageUrl, fileName, fileSize)**

**M·ª•c ƒë√≠ch:** T·∫°o message type 'image' sau khi upload xong

**Code:**
```typescript
sendImageMessage(
  channelId: string, 
  imageUrl: string, 
  fileName?: string, 
  fileSize?: number
): Observable<MessageResponse> {
  
  return this.createMessage({
    channelId,
    text: '',              // Empty text for image messages
    type: 'image',         // Message type
    imageUrl,              // URL returned from upload
    fileName,              // Original filename
    fileSize               // File size in bytes
  });
}
```

**Chi ti·∫øt parameters:**

| Parameter | Type | Required | Example | Purpose |
|-----------|------|----------|---------|---------|
| `channelId` | string | ‚úÖ Yes | "channel-123" | Channel ƒë·ªÉ g·ª≠i message |
| `imageUrl` | string | ‚úÖ Yes | "/uploads/images/photo-123.jpg" | URL t·ª´ upload API |
| `fileName` | string | ‚ùå No | "vacation.jpg" | Original filename |
| `fileSize` | number | ‚ùå No | 3145728 | Size in bytes (for display) |

**createMessage() Internal:**
```typescript
private createMessage(data: any): Observable<MessageResponse> {
  return this.http.post<MessageResponse>(
    `${this.API_URL}`,  // POST /api/messages
    {
      channelId: data.channelId,
      text: data.text || '',
      type: data.type || 'text',
      imageUrl: data.imageUrl,
      fileName: data.fileName,
      fileSize: data.fileSize,
      userId: this.currentUser.id,
      username: this.currentUser.username
    },
    {
      headers: {
        'Authorization': `Bearer ${this.authToken}`,
        'Content-Type': 'application/json'
      }
    }
  );
}
```

**API Request:**
```json
POST /api/messages
Headers: {
  "Authorization": "Bearer eyJhbGc...",
  "Content-Type": "application/json"
}
Body: {
  "channelId": "channel-123",
  "text": "",
  "type": "image",
  "imageUrl": "/uploads/images/photo-1696723200-abc123.jpg",
  "fileName": "vacation.jpg",
  "fileSize": 3145728,
  "userId": "user-456",
  "username": "john_doe"
}
```

---

### BACKEND - Upload Middleware

**File:** `Backend_system/src/middleware/upload.middleware.ts`

---

#### **Function 9: uploadImage (Multer Config)**

**M·ª•c ƒë√≠ch:** Configure Multer cho image uploads

**Code:**
```typescript
export const uploadImage = multer({
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024,  // 5MB limit
    files: 3                     // Max 3 images
  },
  fileFilter: imageFilter
});
```

**Chi ti·∫øt config:**

**Storage Configuration:**
```typescript
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    let uploadPath = uploadsDir;

    if (file.fieldname === 'avatar') {
      uploadPath = avatarsDir;     // uploads/avatars/
    } else if (file.fieldname === 'image') {
      uploadPath = imagesDir;      // uploads/images/
    } else {
      uploadPath = filesDir;       // uploads/files/
    }

    cb(null, uploadPath);
  },
  
  filename: (req, file, cb) => {
    // Generate unique filename with timestamp
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    const name = path.basename(file.originalname, ext);
    cb(null, `${name}-${uniqueSuffix}${ext}`);
  }
});
```

**Filename Generation:**
```javascript
Original file: "vacation-photo.jpg"
  ‚Üì
Extract name: "vacation-photo"
Extract ext: ".jpg"
  ‚Üì
Generate suffix: Date.now() = 1696723200
                 Random = 123456789
  ‚Üì
uniqueSuffix = "1696723200-123456789"
  ‚Üì
Final filename: "vacation-photo-1696723200-123456789.jpg"
  ‚Üì
Full path: "uploads/images/vacation-photo-1696723200-123456789.jpg"
```

**Why unique filenames?**
```
Problem: 2 users upload "photo.jpg"
  User A: photo.jpg ‚Üí Saved
  User B: photo.jpg ‚Üí OVERWRITES User A's file! ‚ùå

Solution: Unique filenames
  User A: photo-1696723200-123.jpg ‚úÖ
  User B: photo-1696723201-456.jpg ‚úÖ
  Both files safe!
```

---

#### **Function 10: imageFilter()**

**M·ª•c ƒë√≠ch:** Filter ch·ªâ cho ph√©p image files

**Code:**
```typescript
const imageFilter = (
  req: any, 
  file: Express.Multer.File, 
  cb: multer.FileFilterCallback
) => {
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);   // Accept file
  } else {
    cb(new Error('Only image files are allowed!'));  // Reject file
  }
};
```

**Chi ti·∫øt:**

**Multer File Object:**
```typescript
file = {
  fieldname: 'image',
  originalname: 'vacation.jpg',
  encoding: '7bit',
  mimetype: 'image/jpeg',
  size: 3145728,
  destination: 'uploads/images/',
  filename: 'vacation-1696723200-123.jpg',
  path: 'uploads/images/vacation-1696723200-123.jpg'
}
```

**MIME Type Check:**
```javascript
Accepted:
  'image/jpeg'.startsWith('image/') = true ‚úÖ
  'image/png'.startsWith('image/') = true ‚úÖ
  'image/gif'.startsWith('image/') = true ‚úÖ

Rejected:
  'video/mp4'.startsWith('image/') = false ‚ùå
  'application/pdf'.startsWith('image/') = false ‚ùå
  'text/plain'.startsWith('image/') = false ‚ùå
```

**Callback Pattern:**
```typescript
cb(null, true)   // Accept: error=null, accept=true
cb(error, false) // Reject: error=Error object, accept=false
```

---

### BACKEND - Upload Route

**File:** `Backend_system/src/routes/upload.routes.ts`

---

#### **Route: POST /api/upload/image**

**Code:**
```typescript
router.post('/image', uploadImage.single('image'), async (req: any, res: any) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No image file provided'
      });
    }

    const fileUrl = getFileUrl(req, req.file.path);

    res.json({
      success: true,
      message: 'Image uploaded successfully',
      data: {
        imageUrl: fileUrl,
        filename: req.file.filename,
        originalName: req.file.originalname,
        size: req.file.size,
        mimeType: req.file.mimetype
      }
    });

  } catch (error) {
    console.error('Image upload error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to upload image'
    });
  }
}, handleUploadError);
```

**Chi ti·∫øt Flow:**

**Step 1: Multer Middleware**
```
Request arrives: POST /api/upload/image
  ‚Üì
Multer middleware: uploadImage.single('image')
  ‚Üì
Process FormData:
  1. Extract file from field 'image'
  2. Validate with imageFilter()
  3. Check file size (< 5MB)
  4. Save to disk: uploads/images/
  5. Add req.file object
  ‚Üì
Continue to route handler
```

**Step 2: Validate File Exists**
```typescript
if (!req.file) {
  // File kh√¥ng ƒë∆∞·ª£c upload (validation failed ho·∫∑c missing)
  return 400 Bad Request
}
```

**Step 3: Generate File URL**
```typescript
const fileUrl = getFileUrl(req, req.file.path);

function getFileUrl(req, filePath) {
  const baseUrl = `${req.protocol}://${req.get('host')}`;
  // "http://localhost:3000"
  
  const relativePath = filePath.replace(/\\/g, '/').replace(/.*\/uploads\//, '/uploads/');
  // "uploads/images/photo-123.jpg" ‚Üí "/uploads/images/photo-123.jpg"
  
  return `${baseUrl}${relativePath}`;
  // "http://localhost:3000/uploads/images/photo-123.jpg"
}
```

**Step 4: Return Response**
```json
Status: 200 OK
Body: {
  "success": true,
  "message": "Image uploaded successfully",
  "data": {
    "imageUrl": "http://localhost:3000/uploads/images/vacation-1696723200-123.jpg",
    "filename": "vacation-1696723200-123.jpg",
    "originalName": "vacation.jpg",
    "size": 3145728,
    "mimeType": "image/jpeg"
  }
}
```

---

## üì∏ COMPLETE IMAGE UPLOAD FLOW

### Full Journey: User ch·ªçn ·∫£nh ‚Üí Hi·ªÉn th·ªã trong chat

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STEP 1: User Interaction (Frontend)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
User trong chat interface
  ‚Üì
Click image icon button üì∑
  ‚Üì
file-input.click() triggered
  ‚Üì
File picker dialog opens
  ‚Üì
User selects: "vacation.jpg" (3MB)

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STEP 2: File Validation (Frontend)                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
onFileSelected() triggered
  ‚Üì
validateFile(file)
  ‚îú‚îÄ> Check type: "image/jpeg" ‚úÖ
  ‚îî‚îÄ> Check size: 3MB < 5MB ‚úÖ
  ‚Üì
Validation PASSED

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STEP 3: Preview Generation (Frontend)                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
URL.createObjectURL(file)
  ‚Üì
Returns: "blob:http://localhost:4200/abc-123-def"
  ‚Üì
this.previewUrl = blob URL
  ‚Üì
Template updates: <img [src]="previewUrl">
  ‚Üì
User sees preview thumbnail

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STEP 4: Upload to Server (Frontend ‚Üí Backend)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
uploadService.uploadImageWithProgress(file, channelId)
  ‚Üì
Create FormData:
  - Append file
  - Append channelId metadata
  ‚Üì
HTTP POST /api/upload/image
  Headers: { Authorization: "Bearer token..." }
  Body: multipart/form-data with file
  ‚Üì
Track progress: 0% ‚Üí 25% ‚Üí 50% ‚Üí 75% ‚Üí 100%
  ‚Üì
Progress bar updates in real-time

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STEP 5: Server Processing (Backend)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Express receives request
  ‚Üì
Multer middleware: uploadImage.single('image')
  ‚Üì
Extract file from multipart data
  ‚Üì
Validate:
  ‚îú‚îÄ> Type: image/* ‚úÖ
  ‚îú‚îÄ> Size: < 5MB ‚úÖ
  ‚îî‚îÄ> File exists ‚úÖ
  ‚Üì
Save to disk:
  Path: uploads/images/vacation-1696723200-123.jpg
  ‚Üì
Add req.file object:
  {
    filename: "vacation-1696723200-123.jpg",
    path: "uploads/images/vacation-1696723200-123.jpg",
    size: 3145728,
    mimetype: "image/jpeg"
  }
  ‚Üì
Continue to route handler

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STEP 6: Generate Response (Backend)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
getFileUrl(req, req.file.path)
  ‚Üì
Returns: "http://localhost:3000/uploads/images/vacation-1696723200-123.jpg"
  ‚Üì
Build response object:
  {
    success: true,
    data: {
      imageUrl: "http://localhost:3000/uploads/images/...",
      filename: "vacation-1696723200-123.jpg",
      originalName: "vacation.jpg",
      size: 3145728,
      mimeType: "image/jpeg"
    }
  }
  ‚Üì
Send response: 200 OK

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STEP 7: Create Message (Frontend)                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Upload complete! Response received
  ‚Üì
Extract imageUrl from response
  ‚Üì
messageService.sendImageMessage(
  channelId,
  imageUrl,
  fileName,
  fileSize
)
  ‚Üì
HTTP POST /api/messages
  Body: {
    "channelId": "channel-123",
    "text": "",
    "type": "image",
    "imageUrl": "http://localhost:3000/uploads/images/...",
    "fileName": "vacation.jpg",
    "fileSize": 3145728
  }

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STEP 8: Save Message (Backend)                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
POST /api/messages received
  ‚Üì
messageController.createMessage()
  ‚Üì
MongoDB insert:
  {
    _id: ObjectId("..."),
    channelId: ObjectId("channel-123"),
    userId: ObjectId("user-456"),
    username: "john_doe",
    text: "",
    type: "image",
    imageUrl: "/uploads/images/vacation-1696723200-123.jpg",
    fileName: "vacation.jpg",
    fileSize: 3145728,
    createdAt: new Date(),
    updatedAt: new Date()
  }
  ‚Üì
Return message object

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STEP 9: Broadcast via Socket.io (Backend)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Message saved successfully
  ‚Üì
Socket.io emit to channel:
  io.to(channelId).emit('message:new', messageData)
  ‚Üì
All users in channel receive event

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ STEP 10: Display in Chat (Frontend)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
SocketService receives 'message:new' event
  ‚Üì
chatComponent.messages.push(newMessage)
  ‚Üì
Template updates:
  <div class="message-item image-message">
    <div class="message-header">
      <span class="username">john_doe</span>
      <span class="timestamp">10:30 AM</span>
    </div>
    <img [src]="message.imageUrl" 
         alt="vacation.jpg" 
         class="message-image"
         (click)="openImageModal(message.imageUrl)">
    <div class="image-info">
      <span>üì∑ vacation.jpg</span>
      <span>3.0 MB</span>
    </div>
  </div>
  ‚Üì
User sees image in chat! ‚úÖ
```

---

## üé¨ COMPLETE FLOW DIAGRAM

```
USER ACTION                    FRONTEND                         BACKEND                        DATABASE
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

1. Click üì∑               ‚Üí    fileInput.click()
                               ‚Üì
2. Select image          ‚Üí    onFileSelected(event)
                               ‚Üì
3. File picked           ‚Üí    validateFile(file)
                               ‚îú‚îÄ> Type check ‚úÖ
                               ‚îî‚îÄ> Size check ‚úÖ
                               ‚Üì
4. Preview shown         ‚Üí    URL.createObjectURL()
                               ‚Üì
                               previewUrl displayed
                               ‚Üì
5. Click Send            ‚Üí    uploadService.uploadImage()
                               ‚Üì
                               FormData created
                               ‚Üì
                               HTTP POST request
                               ‚Üì
                               Progress: 0%...100%     ‚Üí     Express server
                                                              ‚Üì
                                                         Multer middleware
                                                              ‚Üì
                                                         Extract file
                                                              ‚Üì
                                                         Save to disk
                                                              ‚Üì
                                                         Return file URL
                               ‚Üì
6. Upload complete       ‚Üê    Response received
                               ‚Üì
                               imageUrl = response.data.imageUrl
                               ‚Üì
7. Send message          ‚Üí    sendImageMessage()
                               ‚Üì
                               HTTP POST /api/messages   ‚Üí   Message controller
                                                              ‚Üì
                                                         Create message       ‚Üí  MongoDB
                                                              ‚Üì                     ‚Üì
                                                         Socket.io broadcast  Insert doc
                               ‚Üì
8. Receive broadcast     ‚Üê    socket.on('message:new')
                               ‚Üì
                               messages.push(newMessage)
                               ‚Üì
9. Display image         ‚Üí    Template renders
                               ‚Üì
                               <img [src]="imageUrl">
                               ‚Üì
10. Image visible! ‚úÖ
```

---

# 2. T√çNH NƒÇNG VIDEO CALL

## üìä T·ªïng Quan

**Files li√™n quan:**
```
Frontend:
‚îú‚îÄ‚îÄ video-call.component.ts          # Main video call UI
‚îú‚îÄ‚îÄ video-call-button.component.ts   # Call button
‚îú‚îÄ‚îÄ peerjs.service.ts                # PeerJS wrapper
‚îú‚îÄ‚îÄ webrtc.service.ts                # WebRTC low-level
‚îî‚îÄ‚îÄ socket.service.ts                # Signaling

Backend:
‚îú‚îÄ‚îÄ socket.server.ts                 # Socket.io handlers
‚îú‚îÄ‚îÄ video-call.controller.ts         # Call management
‚îî‚îÄ‚îÄ peerjs-server.js                 # PeerJS signaling server
```

**Tech Stack:**
- WebRTC: Peer-to-peer video/audio
- PeerJS: WebRTC wrapper (simplified API)
- Socket.io: Signaling channel
- STUN Servers: NAT traversal

---

## üîß CHI TI·∫æT T·ª™NG FUNCTION

### FRONTEND - PeerJSService

**File:** `Frontend_system/chat-system-frontend/src/app/services/peerjs.service.ts`

---

#### **Function 11: initializePeer()**

**M·ª•c ƒë√≠ch:** Kh·ªüi t·∫°o PeerJS connection

**Code:**
```typescript
private initializePeer(): void {
  try {
    if (this.peer) {
      console.log('üîç PeerJS - Already initialized, skipping');
      return;
    }

    // Generate unique peer ID
    const currentUser = JSON.parse(localStorage.getItem('current_user') || '{}');
    const userId = currentUser.id || 'anonymous';
    const randomSuffix = Math.random().toString(36).substring(2, 8);
    const peerId = `${userId}_${Date.now()}_${randomSuffix}`;

    console.log('üîç PeerJS - Initializing with peer ID:', peerId);

    this.peer = new Peer(peerId, {
      host: 'localhost',
      port: 9000,
      path: '/peerjs',
      debug: 0,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' }
        ]
      }
    });

    // Setup event handlers
    this.peer.on('open', (id) => {
      console.log('üîç PeerJS - Connected with ID:', id);
      this.updateConnectionState();
    });

    this.peer.on('call', (call: any) => {
      console.log('üîç PeerJS - Incoming call from:', call.peer);
      this.answerIncomingCall(call);
    });

    this.peer.on('error', (error) => {
      console.error('üîç PeerJS - Error:', error);
    });

  } catch (error) {
    console.error('üîç PeerJS - Initialization failed:', error);
  }
}
```

**Chi ti·∫øt t·ª´ng b∆∞·ªõc:**

**Step 1: Check Already Initialized**
```typescript
if (this.peer) {
  return;  // Already exists, skip
}
```

**Why check?**
```
Problem: Initialize twice
  ‚Üì
2 PeerJS connections
  ‚Üì
Conflicts, memory leaks! ‚ùå

Solution: Singleton pattern
  ‚Üì
Check if exists
  ‚Üì
Only create if null ‚úÖ
```

**Step 2: Generate Unique Peer ID**
```typescript
const userId = "user-456"
const randomSuffix = Math.random().toString(36).substring(2, 8)
  // "ab3x9z"
const timestamp = Date.now()
  // 1696723200123

peerId = `${userId}_${timestamp}_${randomSuffix}`
  // "user-456_1696723200123_ab3x9z"
```

**Why unique ID?**
```
User A: "user-456_1696723200123_ab3x9z"
User B: "user-789_1696723200124_cd5m2n"

Different IDs:
  ‚úÖ No conflicts
  ‚úÖ Can connect to each other
  ‚úÖ Multiple sessions (same user, different tabs)
```

**Step 3: Create Peer Object**
```typescript
this.peer = new Peer(peerId, { options })
```

**PeerJS Options:**

| Option | Value | Purpose |
|--------|-------|---------|
| `host` | `localhost` | PeerJS server address |
| `port` | `9000` | PeerJS server port |
| `path` | `/peerjs` | Server endpoint path |
| `debug` | `0` | Debug level (0=none, 3=all) |
| `config.iceServers` | STUN servers | NAT traversal servers |

**ICE Servers (STUN):**
```
What is STUN?
  Session Traversal Utilities for NAT
  
Purpose:
  Help peers find each other's public IP addresses
  
Example:
  User A behind router:
    Private IP: 192.168.1.100
    Public IP: ?
    ‚Üì
  Connect to STUN server
    ‚Üì
  STUN returns: "Your public IP is 203.45.67.89"
    ‚Üì
  User A can now tell User B: "Connect to me at 203.45.67.89"
```

**Step 4: Setup Event Handlers**

**Event: 'open'**
```typescript
this.peer.on('open', (id) => {
  console.log('Connected with ID:', id);
});
```
- Fired when: Connection to PeerJS server established
- Parameter `id`: Confirmed peer ID
- Action: Update UI to show "Ready for calls"

**Event: 'call'**
```typescript
this.peer.on('call', (call) => {
  console.log('Incoming call from:', call.peer);
  this.answerIncomingCall(call);
});
```
- Fired when: Another peer calls you
- Parameter `call`: MediaConnection object
- Action: Answer the call automatically

**Event: 'error'**
```typescript
this.peer.on('error', (error) => {
  console.error('PeerJS Error:', error);
});
```
- Fired when: Connection errors
- Common errors:
  - `peer-unavailable`: Peer not online
  - `server-error`: Can't connect to PeerJS server
  - `network`: Network issues

---

#### **Function 12: startCall(peerId: string)**

**M·ª•c ƒë√≠ch:** B·∫Øt ƒë·∫ßu video call v·ªõi user kh√°c

**Code:**
```typescript
async startCall(peerId: string): Promise<boolean> {
  try {
    if (!this.isPeerJSAvailable()) {
      console.error('üîç PeerJS - PeerJS not available');
      return false;
    }

    // Get user media (camera + microphone)
    this.localStream = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    });

    // Make the call
    const call = (this.peer as any).call(peerId, this.localStream);

    if (!call) {
      console.error('üîç PeerJS - Failed to create call');
      return false;
    }

    this.currentCall = call;

    // Handle remote stream
    call.on('stream', (remoteStream: MediaStream) => {
      console.log('üîç PeerJS - Received remote stream');
      this.callEventSubject.next({
        type: 'call_answered',
        data: { remoteStream, call }
      });
    });

    // Handle call end
    call.on('close', () => {
      console.log('üîç PeerJS - Call ended');
      this.endCall();
    });

    // Handle errors
    call.on('error', (error: any) => {
      console.error('üîç PeerJS - Call error:', error);
      this.endCall();
    });

    return true;

  } catch (error) {
    console.error('üîç PeerJS - Failed to start call:', error);
    return false;
  }
}
```

**Chi ti·∫øt t·ª´ng b∆∞·ªõc:**

**Step 1: Check PeerJS Available**
```typescript
if (!this.isPeerJSAvailable()) {
  return false;
}

isPeerJSAvailable(): boolean {
  return this.isPeerJSEnabled && this.peer !== null;
}
```

**Step 2: Get User Media**
```typescript
this.localStream = await navigator.mediaDevices.getUserMedia({
  video: true,
  audio: true
});
```

**getUserMedia() explained:**
```
Browser API for camera/microphone access

Request:
  video: true  ‚Üí Access camera
  audio: true  ‚Üí Access microphone
  ‚Üì
Browser shows permission prompt:
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ Allow "Chat System" to use:         ‚îÇ
  ‚îÇ ‚Ä¢ Your camera                       ‚îÇ
  ‚îÇ ‚Ä¢ Your microphone                   ‚îÇ
  ‚îÇ                                     ‚îÇ
  ‚îÇ [Block]  [Allow]                    ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ‚Üì
User clicks "Allow"
  ‚Üì
Returns: MediaStream object
  {
    id: "stream-abc123",
    active: true,
    getTracks(): [VideoTrack, AudioTrack],
    getVideoTracks(): [VideoTrack],
    getAudioTracks(): [AudioTrack]
  }
  ‚Üì
this.localStream = MediaStream
  ‚Üì
Can display in <video> element:
  <video [srcObject]="localStream" autoplay></video>
```

**Advanced Constraints:**
```typescript
// Basic
getUserMedia({ video: true, audio: true })

// Advanced
getUserMedia({
  video: {
    width: { ideal: 1280 },
    height: { ideal: 720 },
    frameRate: { ideal: 30 },
    facingMode: "user"  // Front camera
  },
  audio: {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true
  }
})
```

**Step 3: Call Peer**
```typescript
const call = this.peer.call(peerId, this.localStream);
```

**What happens:**
```
User A calls User B:

User A (you):
  peer.call("user-B-id", localStream)
    ‚Üì
  Send call request via PeerJS server
    ‚Üì
  Package: {
    from: "user-A-id",
    to: "user-B-id",
    offer: { SDP },
    stream: localStream
  }

User B (receiver):
  peer.on('call', (call) => {
    // Receives call object
    call.answer(theirLocalStream);
  })
    ‚Üì
  Send answer back via PeerJS server
    ‚Üì
  Package: {
    from: "user-B-id",
    to: "user-A-id",
    answer: { SDP },
    stream: theirLocalStream
  }

Connection established!
  ‚Üì
User A sees: User B's video
User B sees: User A's video
```

**SDP (Session Description Protocol):**
```
Offer SDP:
  v=0
  o=- 123456789 2 IN IP4 127.0.0.1
  s=-
  t=0 0
  a=group:BUNDLE 0 1
  m=video 9 UDP/TLS/RTP/SAVPF 96
  a=rtpmap:96 VP8/90000
  m=audio 9 UDP/TLS/RTP/SAVPF 111
  a=rtpmap:111 opus/48000/2

Contains:
  - Media capabilities (video codecs, audio codecs)
  - Network info
  - Encryption keys
```

**Step 4: Handle Remote Stream**
```typescript
call.on('stream', (remoteStream: MediaStream) => {
  this.callEventSubject.next({
    type: 'call_answered',
    data: { remoteStream, call }
  });
});
```

**Event Flow:**
```
Call answered by remote peer
  ‚Üì
WebRTC connection established
  ‚Üì
Remote peer's stream arrives
  ‚Üì
'stream' event fired
  ‚Üì
Emit to callEvents$ observable
  ‚Üì
VideoCallComponent subscribes:
  this.peerService.callEvents$.subscribe(event => {
    if (event.type === 'call_answered') {
      this.remoteStream = event.data.remoteStream;
      this.remoteVideo.nativeElement.srcObject = remoteStream;
    }
  });
  ‚Üì
Remote video displays in UI! ‚úÖ
```

---

#### **Function 13: answerIncomingCall(call)**

**M·ª•c ƒë√≠ch:** Tr·∫£ l·ªùi cu·ªôc g·ªçi ƒë·∫øn

**Code:**
```typescript
private async answerIncomingCall(call: any): Promise<void> {
  try {
    // Get local media stream
    if (!this.localStream) {
      this.localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      });
    }

    // Answer the call with local stream
    call.answer(this.localStream);

    // Handle remote stream
    call.on('stream', (remoteStream: MediaStream) => {
      console.log('üîç PeerJS - Received remote stream');
      this.callEventSubject.next({
        type: 'call_answered',
        data: { remoteStream, call }
      });
    });

    // Handle call close
    call.on('close', () => {
      this.endCall();
    });

  } catch (error) {
    console.error('üîç PeerJS - Failed to answer call:', error);
  }
}
```

**Chi ti·∫øt Flow:**

```
User B receives call from User A
  ‚Üì
peer.on('call', (call) => {
  answerIncomingCall(call);
})
  ‚Üì
Step 1: Get local media
  if (!localStream) {
    localStream = await getUserMedia();
  }
  ‚Üì
Step 2: Answer v·ªõi local stream
  call.answer(localStream)
  ‚Üì
  Sends to User A:
    - Answer SDP
    - Local stream tracks
  ‚Üì
Step 3: Wait for remote stream
  call.on('stream', (remoteStream) => {
    // User A's video/audio arrives
    this.remoteStream = remoteStream;
  })
  ‚Üì
Connection complete!
  User A sees: User B's video
  User B sees: User A's video
```

**call.answer() explained:**
```javascript
// Caller side (User A)
const call = peer.call("user-B-id", localStream);
  ‚Üì Sends: Offer

// Receiver side (User B)
peer.on('call', (call) => {
  call.answer(localStream);
  ‚Üì Sends: Answer
});

// Offer-Answer Exchange:
User A ‚Üí [Offer] ‚Üí PeerJS Server ‚Üí User B
User B ‚Üí [Answer] ‚Üí PeerJS Server ‚Üí User A
  ‚Üì
WebRTC connection established!
```

---

#### **Function 14: endCall()**

**M·ª•c ƒë√≠ch:** K·∫øt th√∫c cu·ªôc g·ªçi v√† cleanup

**Code:**
```typescript
endCall(): void {
  console.log('üîç PeerJS - Ending call');

  // Stop local stream tracks
  if (this.localStream) {
    this.localStream.getTracks().forEach(track => {
      track.stop();
    });
    this.localStream = null;
  }

  // Close current call
  if (this.currentCall) {
    this.currentCall.close();
    this.currentCall = null;
  }

  // Emit call ended event
  this.callEventSubject.next({
    type: 'call_ended',
    data: null
  });
}
```

**Chi ti·∫øt Cleanup:**

**Step 1: Stop Media Tracks**
```typescript
this.localStream.getTracks()
  ‚Üì
Returns: [VideoTrack, AudioTrack]
  ‚Üì
forEach(track => track.stop())
  ‚Üì
VideoTrack.stop()
  ‚îî‚îÄ> Camera LED turns OFF üì∑‚ùå
  ‚Üì
AudioTrack.stop()
  ‚îî‚îÄ> Microphone muted üé§‚ùå
  ‚Üì
Devices released! User can use in other apps
```

**MediaStreamTrack.stop():**
```
Before stop():
  track.readyState = "live"
  Camera: ON üì∑‚úÖ
  Microphone: ON üé§‚úÖ

After stop():
  track.readyState = "ended"
  Camera: OFF üì∑‚ùå
  Microphone: OFF üé§‚ùå
  
Devices freed for other apps! ‚úÖ
```

**Step 2: Close PeerJS Call**
```typescript
this.currentCall.close()
```

**What happens:**
```
call.close()
  ‚Üì
Send close signal to remote peer
  ‚Üì
Close RTCPeerConnection
  ‚Üì
Stop receiving remote stream
  ‚Üì
Cleanup WebRTC resources
```

**Step 3: Emit Event**
```typescript
this.callEventSubject.next({
  type: 'call_ended',
  data: null
});
```

**Subscribers receive:**
```
videoCallComponent.ngOnInit():
  this.peerService.callEvents$.subscribe(event => {
    if (event.type === 'call_ended') {
      this.showCallInterface = false;
      this.remoteStream = null;
      this.showNotification('Call ended');
    }
  });
```

---

#### **Function 15: toggleAudio()** 

**M·ª•c ƒë√≠ch:** B·∫≠t/t·∫Øt microphone

**Code:**
```typescript
toggleAudio(): void {
  if (this.localStream) {
    const audioTracks = this.localStream.getAudioTracks();
    audioTracks.forEach(track => {
      track.enabled = !track.enabled;
    });
    
    this.isAudioEnabled = !this.isAudioEnabled;
    console.log('üîç PeerJS - Audio toggled:', this.isAudioEnabled);
  }
}
```

**Chi ti·∫øt:**

**MediaStreamTrack Properties:**
```typescript
AudioTrack {
  kind: "audio",
  label: "Microphone (Built-in)",
  enabled: true,          // ‚Üê Toggle this!
  muted: false,
  readyState: "live"
}
```

**Toggle Logic:**
```javascript
Initial state:
  track.enabled = true   // Mic ON üé§‚úÖ
  User hears: Your voice

Click mute button:
  track.enabled = !track.enabled
  ‚Üì
  track.enabled = false  // Mic OFF üé§‚ùå
  User hears: Silence

Click unmute button:
  track.enabled = !track.enabled
  ‚Üì
  track.enabled = true   // Mic ON üé§‚úÖ
  User hears: Your voice again
```

**Difference: enabled vs stop():**
```
track.enabled = false:
  ‚úÖ Temporary mute
  ‚úÖ Can unmute: enabled = true
  ‚úÖ Device still in use
  ‚úÖ Reversible

track.stop():
  ‚ùå Permanent stop
  ‚ùå Cannot restart
  ‚ùå Device released
  ‚ùå Not reversible (need getUserMedia again)
```

**UI Update:**
```html
<button (click)="toggleAudio()">
  <mat-icon>{{ isAudioEnabled ? 'mic' : 'mic_off' }}</mat-icon>
</button>
```

---

#### **Function 16: toggleVideo()**

**M·ª•c ƒë√≠ch:** B·∫≠t/t·∫Øt camera

**Code:**
```typescript
toggleVideo(): void {
  if (this.localStream) {
    const videoTracks = this.localStream.getVideoTracks();
    videoTracks.forEach(track => {
      track.enabled = !track.enabled;
    });
    
    this.isVideoEnabled = !this.isVideoEnabled;
    console.log('üîç PeerJS - Video toggled:', this.isVideoEnabled);
  }
}
```

**Similar to toggleAudio():**

```javascript
Initial: Camera ON üì∑‚úÖ
  ‚Üì
Click "Turn off camera"
  ‚Üì
track.enabled = false
  ‚Üì
Remote user sees: Black screen (your video stopped)
  ‚Üì
Click "Turn on camera"
  ‚Üì
track.enabled = true
  ‚Üì
Remote user sees: Your video again! ‚úÖ
```

**Local Video Preview:**
```html
<video #localVideo 
       [srcObject]="localStream" 
       [style.opacity]="isVideoEnabled ? 1 : 0"
       muted 
       autoplay>
</video>
```

**CSS Trick:**
```css
/* When camera off, show placeholder */
.video-placeholder {
  display: block;
  opacity: 1;
}

video.camera-off {
  opacity: 0;  /* Hide video */
}
```

---

### BACKEND - Socket Server

**File:** `Backend_system/src/sockets/socket.server.ts`

---

#### **Function 17: handleVideoCallInitiate()**

**M·ª•c ƒë√≠ch:** X·ª≠ l√Ω request b·∫Øt ƒë·∫ßu call

**Code:**
```typescript
private async handleVideoCallInitiate(
  socket: AuthenticatedSocket, 
  data: { recipientId: string; channelId: string }
): Promise<void> {
  
  try {
    const { recipientId, channelId } = data;
    
    // Create video call record in database
    const callData = {
      callerId: socket.userId,
      recipientId: recipientId,
      channelId: channelId,
      status: 'ringing',
      startTime: new Date()
    };
    
    const call = await videoCallService.initiateCall(callData);
    
    // Notify recipient via Socket.io
    const recipientSocketId = this.getUserSocketId(recipientId);
    if (recipientSocketId) {
      this.io.to(recipientSocketId).emit('video_call_incoming', {
        callId: call._id,
        callerId: socket.userId,
        callerName: socket.username,
        channelId: channelId
      });
    }
    
    // Confirm to caller
    socket.emit('video_call_initiated', {
      callId: call._id,
      status: 'ringing'
    });
    
    console.log(`Video call initiated: ${socket.username} ‚Üí ${recipientId}`);
    
  } catch (error) {
    console.error('Error initiating video call:', error);
    socket.emit('video_call_error', {
      message: 'Failed to initiate call'
    });
  }
}
```

**Chi ti·∫øt Flow:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User A clicks "Call" button                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ‚Üì
Frontend emits socket event:
  socket.emit('video_call_initiate', {
    recipientId: "user-B-id",
    channelId: "channel-123"
  })
  ‚Üì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Backend receives event
  ‚Üì
handleVideoCallInitiate(socket, data)
  ‚Üì
Step 1: Extract data
  {
    recipientId: "user-B-id",
    channelId: "channel-123"
  }
  ‚Üì
Step 2: Create call record in MongoDB
  {
    _id: "call-789",
    callerId: "user-A-id",
    recipientId: "user-B-id",
    channelId: "channel-123",
    status: "ringing",
    startTime: "2025-10-08T10:30:00.000Z"
  }
  ‚Üì
Step 3: Find recipient's socket
  getUserSocketId("user-B-id")
    ‚Üì
  Returns: "socket-xyz789"
  ‚Üì
Step 4: Notify recipient
  io.to("socket-xyz789").emit('video_call_incoming', {
    callId: "call-789",
    callerId: "user-A-id",
    callerName: "User A"
  })
  ‚Üì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
User B's frontend receives event
  ‚Üì
Show incoming call UI:
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ üìû Incoming Call                    ‚îÇ
  ‚îÇ From: User A                        ‚îÇ
  ‚îÇ                                     ‚îÇ
  ‚îÇ [Reject]  [Answer]                  ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

#### **Function 18: handleVideoCallAccept()**

**M·ª•c ƒë√≠ch:** X·ª≠ l√Ω khi user accept call

**Code:**
```typescript
private async handleVideoCallAccept(
  socket: AuthenticatedSocket,
  data: { callId: string }
): Promise<void> {
  
  try {
    const { callId } = data;
    
    // Update call status in database
    await videoCallService.acceptCall(callId);
    
    // Get call details
    const call = await videoCallService.getCallById(callId);
    
    // Notify caller that call was accepted
    const callerSocketId = this.getUserSocketId(call.callerId);
    if (callerSocketId) {
      this.io.to(callerSocketId).emit('video_call_accepted', {
        callId: callId,
        acceptedBy: socket.userId
      });
    }
    
    // Confirm to recipient
    socket.emit('video_call_joined', {
      callId: callId
    });
    
    console.log(`Video call accepted: ${socket.username} accepted call ${callId}`);
    
  } catch (error) {
    console.error('Error accepting video call:', error);
    socket.emit('video_call_error', {
      message: 'Failed to accept call'
    });
  }
}
```

**Chi ti·∫øt Flow:**

```
User B clicks "Answer" button
  ‚Üì
Frontend emits:
  socket.emit('video_call_accept', {
    callId: "call-789"
  })
  ‚Üì
Backend receives:
  handleVideoCallAccept()
    ‚Üì
  Step 1: Update MongoDB
    {
      _id: "call-789",
      status: "ringing" ‚Üí "active",
      acceptedAt: new Date()
    }
    ‚Üì
  Step 2: Notify caller (User A)
    io.to(callerSocketId).emit('video_call_accepted', {
      callId: "call-789",
      acceptedBy: "user-B-id"
    })
    ‚Üì
User A's frontend receives:
  socket.on('video_call_accepted', (data) => {
    this.callStatus = 'active';
    this.startPeerConnection(); // Start WebRTC
  })
  ‚Üì
WebRTC connection begins!
```

---

#### **Function 19: handleVideoCallOffer()** (WebRTC Signaling)

**M·ª•c ƒë√≠ch:** Forward WebRTC offer t·ª´ caller to recipient

**Code:**
```typescript
private handleVideoCallOffer(
  socket: AuthenticatedSocket,
  data: CallOffer
): void {
  
  const { to, offer, callId } = data;
  
  console.log(`Video call offer: ${socket.username} ‚Üí ${to}`);
  
  const recipientSocketId = this.getUserSocketId(to);
  if (recipientSocketId) {
    this.io.to(recipientSocketId).emit('video_call_offer', {
      from: socket.userId,
      offer: offer,
      callId: callId
    });
  }
}
```

**WebRTC Signaling Flow:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User A (Caller)                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ‚Üì
Create RTCPeerConnection
  ‚Üì
peerConnection.createOffer()
  ‚Üì
Returns: SDP Offer
  {
    type: "offer",
    sdp: "v=0\r\no=- ... m=video ..."
  }
  ‚Üì
Send via Socket.io:
  socket.emit('video_call_offer', {
    to: "user-B-id",
    offer: { type: "offer", sdp: "..." },
    callId: "call-789"
  })

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Backend: handleVideoCallOffer()
  ‚Üì
Forward to User B:
  io.to(userBSocketId).emit('video_call_offer', {
    from: "user-A-id",
    offer: { type: "offer", sdp: "..." }
  })

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User B (Recipient)                                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ‚Üì
Receives: socket.on('video_call_offer', (data) => {})
  ‚Üì
Create RTCPeerConnection
  ‚Üì
peerConnection.setRemoteDescription(data.offer)
  ‚Üì
peerConnection.createAnswer()
  ‚Üì
Returns: SDP Answer
  ‚Üì
Send back via Socket.io:
  socket.emit('video_call_answer', {
    to: "user-A-id",
    answer: { type: "answer", sdp: "..." }
  })

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Backend: handleVideoCallAnswer()
  ‚Üì
Forward to User A:
  io.to(userASocketId).emit('video_call_answer', {
    from: "user-B-id",
    answer: { type: "answer", sdp: "..." }
  })

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
User A receives answer
  ‚Üì
peerConnection.setRemoteDescription(answer)
  ‚Üì
Connection established! üéâ
```

**SDP Exchange:**
```
Offer (User A ‚Üí User B):
  "I can send video with VP8 codec at 720p, audio with Opus codec"

Answer (User B ‚Üí User A):
  "I accept! I can receive VP8 video and Opus audio"

Result:
  Both agree on codecs, resolution, etc.
  ‚Üì
  Start streaming! ‚úÖ
```

---

#### **Function 20: handleVideoCallIceCandidate()**

**M·ª•c ƒë√≠ch:** Forward ICE candidates cho NAT traversal

**Code:**
```typescript
private handleVideoCallIceCandidate(
  socket: AuthenticatedSocket,
  data: IceCandidate
): void {
  
  const { to, candidate, callId } = data;
  
  console.log(`ICE candidate: ${socket.username} ‚Üí ${to}`);
  
  const recipientSocketId = this.getUserSocketId(to);
  if (recipientSocketId) {
    this.io.to(recipientSocketId).emit('video_call_ice_candidate', {
      from: socket.userId,
      candidate: candidate,
      callId: callId
    });
  }
}
```

**ICE Candidates explained:**

**What is ICE?**
```
ICE = Interactive Connectivity Establishment

Purpose:
  Find best path to connect peers through firewalls/NATs

Process:
  1. Gather candidates (possible connection paths)
  2. Exchange candidates with remote peer
  3. Test all candidates
  4. Select best working candidate
```

**Candidate Types:**
```
Host Candidate:
  type: "host"
  address: "192.168.1.100"  (local IP)
  port: 54321
  ‚Üì Direct connection (same network)

Server Reflexive Candidate:
  type: "srflx"
  address: "203.45.67.89"   (public IP from STUN)
  port: 12345
  ‚Üì Connection via STUN server

Relay Candidate:
  type: "relay"
  address: "relay.server.com"
  port: 3478
  ‚Üì Connection via TURN relay server (last resort)
```

**ICE Exchange Flow:**
```
User A:
  peerConnection.onicecandidate = (event) => {
    if (event.candidate) {
      socket.emit('video_call_ice_candidate', {
        to: "user-B-id",
        candidate: event.candidate
      });
    }
  };
  ‚Üì Discovers: 5 candidates
  ‚Üì Sends all 5 to User B via signaling

User B:
  socket.on('video_call_ice_candidate', (data) => {
    peerConnection.addIceCandidate(data.candidate);
  });
  ‚Üì Receives: 5 candidates from User A
  ‚Üì Tests each one
  ‚Üì Selects best: Host candidate (fastest)
  ‚Üì
Connection established via best path! ‚úÖ
```

---

## üé¨ COMPLETE VIDEO CALL FLOW

```
USER A (CALLER)                    BACKEND                    USER B (RECIPIENT)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

1. Click "Call" button
   ‚Üì
2. getUserMedia()
   ‚Üì Camera/Mic ON üì∑üé§
   ‚Üì
3. Initialize PeerJS
   peerId: "userA_123_abc"
   ‚Üì
4. Emit socket event:
   'video_call_initiate'
   { recipientId: "userB" }
                              ‚Üí  handleVideoCallInitiate()
                                 ‚Üì
                                 MongoDB: Create call record
                                 ‚Üì
                                 Forward to User B socket
                                                           ‚Üí  5. Receive event:
                                                              'video_call_incoming'
                                                              ‚Üì
                                                           6. Show incoming call UI
                                                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                                              ‚îÇ üìû User A calling‚îÇ
                                                              ‚îÇ [Reject][Answer] ‚îÇ
                                                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                              ‚Üì
                                                           7. Click "Answer"
                                                              ‚Üì
                                                           8. getUserMedia()
                                                              ‚Üì Camera/Mic ON
                                                              ‚Üì
                                                           9. Emit socket:
                                                              'video_call_accept'
                              ‚Üê  handleVideoCallAccept()
                                 ‚Üì
                                 MongoDB: Update status
                                 ‚Üì
                                 Forward to User A
10. Receive: 'video_call_accepted'  ‚Üê
    ‚Üì
11. Start PeerJS call:
    peer.call("userB_456_xyz", localStream)
    ‚Üì
    (Offer SDP)
                              ‚Üí  PeerJS Server
                                 ‚Üì
                                 Route to User B
                                                           ‚Üí  12. Receive call:
                                                              peer.on('call', (call) => {
                                                                call.answer(localStream)
                                                              })
                                                              ‚Üì
                                                              (Answer SDP)
                              ‚Üê  PeerJS Server
                                 ‚Üì
13. Receive answer       ‚Üê    Route to User A
    ‚Üì
14. ICE candidates exchange:
    ‚îå‚îÄ> emit ICE        ‚Üí     Forward           ‚Üí           addIceCandidate() ‚îÄ‚îê
    ‚îÇ                                                                            ‚îÇ
    ‚îî‚îÄ addIceCandidate() ‚Üê    Forward           ‚Üê           emit ICE          ‚îÄ‚îò
    ‚Üì
15. Connection established!
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ P2P (Peer-to-Peer) connection                                      ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ User A ‚Üê‚Üí Direct stream ‚Üê‚Üí User B                                 ‚îÇ
    ‚îÇ (NO server in between! Just signaling for setup)                   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚Üì
16. Both see each other:
    User A sees: User B's video/audio
    User B sees: User A's video/audio
    ‚Üì
‚úÖ Video call active!
```

---

## üé• VIDEO CALL COMPONENTS

### Component Hierarchy

```
VideoCallComponent (Main UI)
  ‚îú‚îÄ‚îÄ localVideo: HTMLVideoElement      # Your camera
  ‚îú‚îÄ‚îÄ remoteVideo: HTMLVideoElement     # Other person's camera
  ‚îÇ
  ‚îú‚îÄ‚îÄ Controls:
  ‚îÇ   ‚îú‚îÄ‚îÄ toggleAudio() ‚Üí Mute/Unmute mic
  ‚îÇ   ‚îú‚îÄ‚îÄ toggleVideo() ‚Üí Camera on/off
  ‚îÇ   ‚îú‚îÄ‚îÄ shareScreen() ‚Üí Screen sharing
  ‚îÇ   ‚îî‚îÄ‚îÄ endCall() ‚Üí Hang up
  ‚îÇ
  ‚îî‚îÄ‚îÄ Uses Services:
      ‚îú‚îÄ‚îÄ PeerJSService ‚Üí P2P connection
      ‚îú‚îÄ‚îÄ SocketService ‚Üí Signaling
      ‚îî‚îÄ‚îÄ WebRTCService ‚Üí Low-level WebRTC
```

---

## 3. FLOW DIAGRAMS

### Complete Image Upload Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  USER    ‚îÇ ‚Üí   ‚îÇ FRONTEND ‚îÇ ‚Üí   ‚îÇ BACKEND  ‚îÇ ‚Üí   ‚îÇ   DISK   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ 1. Select      ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ    image       ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ 2. Validate     ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ    (type,size)  ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ 3. Preview     ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ    shown       ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ 4. Click Send  ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ 5. FormData     ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ    POST /upload ‚îÇ                ‚îÇ
     ‚îÇ                ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ 6. Multer      ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ    process     ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ 7. Save file   ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ 8. Return URL   ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ 9. POST /messages                ‚îÇ
     ‚îÇ                ‚îÇ    (with imageUrl)               ‚îÇ
     ‚îÇ                ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ 10. MongoDB    ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ     save       ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ 11. Socket.io  ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ     broadcast  ‚îÇ
     ‚îÇ                ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ 12. Image      ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ     displayed  ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
```

### Complete Video Call Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  USER A  ‚îÇ     ‚îÇ FRONTEND ‚îÇ     ‚îÇ  BACKEND ‚îÇ     ‚îÇ  USER B  ‚îÇ
‚îÇ (CALLER) ‚îÇ     ‚îÇ SERVICES ‚îÇ     ‚îÇ  SOCKET  ‚îÇ     ‚îÇ(RECEIVER)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ 1. Click Call  ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ 2. getUserMedia ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ    üì∑üé§ ON      ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ 3. Initiate     ‚îÇ                ‚îÇ
     ‚îÇ                ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ 4. Notify B    ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ 5. Show        ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ    incoming UI ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ 6. Click Answer‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ 7. Call         ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ    accepted     ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ 8. peer.call()  ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ    (Offer SDP)  ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ>‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ     PeerJS      ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ     Server      ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ<‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ 9. call.answer()‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ   (Answer SDP) ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ 10. ICE candidates exchange      ‚îÇ
     ‚îÇ                ‚îÇ<‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê>‚îÇ<‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê>‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ 11. P2P Connection Established   ‚îÇ
     ‚îÇ                ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                ‚îÇ     (Direct stream, no server)   ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ 12. Video call ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ     active! üìπ ‚îÇ                 ‚îÇ           üìπ   ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                 ‚îÇ                ‚îÇ
     ‚îÇ                ‚îÇ                 ‚îÇ                ‚îÇ
```

---

## 4. TROUBLESHOOTING

### Common Issues

#### Issue 1: Image Upload Fails

**Symptoms:**
```
Error: "File type not allowed"
Error: "File too large"
Error: "Upload failed"
```

**Solutions:**
```typescript
// Check 1: File type
console.log(file.type);  // Must be image/*

// Check 2: File size
console.log(file.size);  // Must be < 5MB (5242880 bytes)

// Check 3: Backend running
// Port 3000 must be active

// Check 4: Multer config
// Check upload.middleware.ts settings
```

---

#### Issue 2: Video Call Won't Connect

**Symptoms:**
```
- "PeerJS not available"
- Call starts but no video/audio
- Connection drops immediately
```

**Solutions:**
```bash
# Check 1: PeerJS server running
npm run peerjs  # Must be on port 9000

# Check 2: Camera/microphone permissions
# Browser should show permission prompt

# Check 3: HTTPS requirement
# WebRTC requires HTTPS (or localhost)

# Check 4: Firewall
# Check if ports 9000, 3000 are open
```

---

## üéØ T√ìM T·∫ÆT

### Image Upload Functions

| Function | File | Purpose |
|----------|------|---------|
| `onFileSelected()` | image-upload.component.ts | Handle file selection |
| `validateFile()` | image-upload.component.ts | Validate type & size |
| `handleSingleFile()` | image-upload.component.ts | Process 1 file |
| `uploadImage()` | upload.service.ts | Upload to server |
| `uploadImageWithProgress()` | upload.service.ts | Upload with progress |
| `sendImageMessage()` | message.service.ts | Create image message |
| `imageFilter()` | upload.middleware.ts | Server-side validation |
| `POST /api/upload/image` | upload.routes.ts | Upload endpoint |

### Video Call Functions

| Function | File | Purpose |
|----------|------|---------|
| `initializePeer()` | peerjs.service.ts | Initialize PeerJS |
| `startCall()` | peerjs.service.ts | Initiate call |
| `answerIncomingCall()` | peerjs.service.ts | Answer call |
| `endCall()` | peerjs.service.ts | Hang up |
| `toggleAudio()` | peerjs.service.ts | Mute/unmute |
| `toggleVideo()` | peerjs.service.ts | Camera on/off |
| `handleVideoCallInitiate()` | socket.server.ts | Handle call request |
| `handleVideoCallAccept()` | socket.server.ts | Handle answer |
| `handleVideoCallOffer()` | socket.server.ts | Forward SDP offer |
| `handleVideoCallAnswer()` | socket.server.ts | Forward SDP answer |
| `handleVideoCallIceCandidate()` | socket.server.ts | Forward ICE candidates |

---

**Last Updated:** October 8, 2025  
**Author:** David Nguyen  
**Status:** Complete Documentation ‚úÖ
